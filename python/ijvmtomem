#!/usr/bin/env python3

"""
ECE Project Mic-1
Title: Program Converter for ijvm-files
Author: Florian Zwittnigg
Date: 17.11.2021
Rev.: 1.0 

This program convert a .ijvm into a .txt, which can be later
interpreted by a mic1 processor. The last row will be padded
so there are always 8 signs in one row (8 signs are equally
to 4 commands)
"""

import os
import sys
import argparse

# Reading the file and hand over the content to main
def read_file(filename:str):
        f = open(f'{filename}', mode='rb')

        fileContent = f.read()
        f.close()

        return fileContent

# convert binary data to hex dataformat for ASCII
def convert_content(fileContent:bytes):
        hex_string = fileContent.hex()
        
        n = 8           # size of one row
        file_header = hex_string[0 : n]
        mem_addr_pool = hex_string[n : 2*n] # represent the place of the constant pool in the memory
        mem_addr_pool_int = int(mem_addr_pool, 16)
        con_poolsize = hex_string[2*n : 3*n]
        size_pooldata = int(con_poolsize, 16)

        k = 3*n+(size_pooldata*2)           # end of pooldata 
        pooldata = hex_string[3*n : k]      

        mem_addr_text = hex_string[k : k + n] # represent the place of the text in the memory
        mem_addr_text_int = int(mem_addr_text, 16)
        con_textsize = hex_string[k + n : k + 2*n]
        textsize = int(con_textsize, 16)

        m = k +  2*n +(textsize*2) # end of textdata
        textdata = hex_string[k + 2*n : m]

        print("Fileheader: " + file_header)
        print("Adresse Pool: " + mem_addr_pool)
        print("Adresse Pool in Dezimal: ", mem_addr_pool_int)
        print("Größe der Pooldaten (Konstanten) in Hexadezimal: " + con_poolsize)
        print("Größe des Pooldaten (Konstanten) in Dezimal: ",  size_pooldata)
        print("Pooldaten: " + pooldata)

        print("Adresse Text: " + mem_addr_text)
        print("Adresse Textes in Dezimal: ", mem_addr_text_int)
        print("Größe des Textes in Hexadezimal: " + con_textsize)
        print("Größe des Textes in Dezimal: ",  textsize)
        print("Textdaten Vor dem Padding: " + textdata)

        rest_of_textdata = textsize % 4
        textsize_correct_data = textsize - rest_of_textdata

        last_row = hex_string[k + 2* (n + textsize_correct_data) : m]
        last_row_length = len(last_row)
        correct_last_row = last_row.rjust(8,"0")        # padding last row

        print("Letzte Zeile: ", last_row)
        print("Länge letzte Zeile: ", last_row_length)
        print("gepaddete letzte Zeile: ", correct_last_row)

        hex_string_padded = hex_string[0 : len(hex_string)-last_row_length] + correct_last_row

        if(file_header != "1deadfad"):
                print("Falsches File geladen!")

        split_strings = [hex_string_padded[index : index + n] + "\n" for index in range(8, len(hex_string_padded), n)]
        # split_strings = [hex_string[index : index + n] + "\n" for index in range(8, len(hex_string), n)]
        # new_string = .join([split_strings[index*10 : index * 10 +9] for index in range(0,len(split_strings), 10]

        return split_strings

# create .txt-File in same directory and write the converted data into it
def write_file(fileContent, filename):
        base = os.path.basename(filename)
        output_filename = os.path.splitext(base)[0]
       
        file = open(f'{output_filename}.txt', "w")

        file.writelines(fileContent)
        
        file.close()

if __name__=='__main__':
    #parsing commandline
    parser = argparse.ArgumentParser(description='Convert Binary to ASCII')
    parser.add_argument('filename', help='filename of binaryfile without file extension')
    args = parser.parse_args()
    
    content_of_file = read_file(args.filename)
    writable_content = convert_content(content_of_file)      
    write_file(writable_content, args.filename)